{
    "contents" : "## This file holds the R wrapper using the Funz open API. \n## It allows Funz to be used from R, without the GUI.\n## Funz.run(...) to launch remote calculations (providing input files + code name) within R, using the code like any R function.\n## Funz.design(...) to call Funz DoE plugins from R.\n## \n## License: BSD\n## Author: Y. Richet\n\n################################# Example ######################################\n#\n## 1. Create a R function calling an external Monte Carlo code of neutronic launched (remotely) on Funz grid:\n## (Suppose you have installed and configured Funz environment and MCNP)\n#>  godiva = function(r) {\n#>    Funz.run(model = \"MCNP_5\",input.files = file.path(FUNZ_HOME,\"samples\",\"godiva.p\"),input.design = r)$mean_keff\n#>  }\n#\n## 2. Now, try this function for an arbitrary \"r\" value:\n#> godiva(data.frame(r=9.0))\n#\n## Result:\n## [1] 1.02042\n#\n## 3. Again, try this function, but for many arbitrary \"r\" value:\n## (Note that MCNP calculations are launched in parallel, thanks to Funz grid)\n#> godiva(data.frame(r=1:10))\n#\n## Result:\n##  [1] 0.11860 0.23928 0.36149 0.48200 0.59928 0.71293 0.82090 0.92365 1.02042\n## [10] 1.11112\n#\n## 4. Let's find the radius leading to keff = 1.0 +/- 0.001\n#> d = Funz.design(design=\"Dichotomy\",input.variables=list(r=\"[1,20]\"),fun=godiva,options=list(Output_precision=0.001,Output_target_value=1.0), verbose.level=1)\n#\n## Result:\n## $r\n## [1] \"8.776501196538314\"\n## \n## $data\n## [1] \"| r\\t| Output\\t|\\n| 1.0\\t| 0.1186\\t|\\n| 20.0\\t| 1.69179\\t|\\n| 10.5\\t| 1.15292\\t|\\n| 8.754169698698966\\t| 0.99702\\t|\\n| 8.743348751168663\\t| 0.99634\\t|\\n| 8.764997608766679\\t| 0.99798\\t|\\n| 8.787778157176508\\t| 0.99989\\t|\\n| 8.776501196538314\\t| 1.00007\\t|\\n| 8.799054062084672\\t| 1.00265\\t|\\n\"\n## \n## $`Input parameter value`\n## [1] \"<br/>r = 8.776501196538314<br/>Output = 1.00007<br/><img src='././dichotomy.png' width='400' height='400'/>\"\n## \n## $information\n## [1] \"  Output precision:\\t0.001\\n  Output target value:\\t1\\n\"\n##\n#> cat(d$data)\n## | r                 | Output    |\n## | 1.0               | 0.1186    |\n## | 20.0              | 1.69179   |\n## | 10.5              | 1.15292   |\n## | 8.754169698698966 | 0.99702   |\n## | 8.743348751168663 | 0.99634   |\n## | 8.764997608766679 | 0.99798   |\n## | 8.787778157176508 | 0.99989   |\n## | 8.776501196538314 | 1.00007   |\n## | 8.799054062084672 | 1.00265   |\n################################################################################\n\n#' Java class shortcuts\n.JNI.Void = \"V\"\n.JNI.boolean = \"Z\"\n.Object = \"java/lang/Object\"\n.JNI.Object = \"Ljava/lang/Object;\"\n.File = \"java/io/File\"\n.JNI.File.array = \"[Ljava/io/File;\"\n.String = \"java/lang/String\"\n.JNI.String = \"Ljava/lang/String;\"\n.JNI.String.array = \"[Ljava/lang/String;\"\n.LinkedHashMap = \"java/util/LinkedHashMap\" # in order to guarantee order of keys\n.HashMap = \"java/util/HashMap\"\n.Map = \"java/util/Map\"\n.JNI.Map = \"Ljava/util/Map;\"\n.Shell = \"org/funz/api/Shell\"\n.RunShell = \"org/funz/api/RunShell\"\n.DesignShell = \"org/funz/api/DesignShell\"\n.ASCII = \"org/funz/util/ASCII\"\n.Constants = \"org/funz/Constants\"\n.System = \"java/lang/System\"\n\n.jdelete <- function(jo){\n    .jcall(.Shell,.JNI.Void,\"delete\",.jcast(jo,new.class=.Object))\n}\n\n.is.absolute <- function(pathname) {\n    path = unlist(strsplit(pathname, \"[/\\\\]\"))\n    !(length(path) == 0) && (path[1] == \"\" || regexpr(\"^.:$\", path[1]) != -1);\n}\n\n#' Initialize Funz environment.\n#' example: \n#'   FUNZ_HOME=\"c:\\\\Program Files\\\\Funz\"\n#'   Funz.init(FUNZ_HOME)\n#' @param FUNZ_HOME set to Funz installation path.\n#' @param verbose.level verbosity of Funz workbench.\n#' @param headless set to TRUE to force a \"no display\" environment.\n#' @param parameters list of JVM startup parameters (like -D...=...).\n#' @param console.visible set to TRUE to display a Java panel with log informations. Need a graphical display environment.\n#' @param math.console.visible set to TRUE to display a Java panel with math backend log informations. Need a graphical display environment.\n#' @param ... optional parameters passed to '.jinit' call.\nFunz.init <- function(FUNZ_HOME, verbose.level=NULL, headless=NULL, parameters = c(\"-Xmx512m\"), console.visible=FALSE, math.console.visible=FALSE, ...) {\n    if (!require(rJava)) \n        stop(\"rJava package (> 0.9-0) is required.\")\n    \n    rJava.version = packageDescription('rJava')$Version\n    if (compareVersion(rJava.version, \"0.9-0\") < 0) \n        stop(paste(\"Installed rJava version (\",rJava.version,\") is too old. Please update to >0.9-0\"))\n    \n    if (!file.exists(FUNZ_HOME)) \n        stop(paste(\"FUNZ_HOME environment variable not correctly set: FUNZ_HOME=\",FUNZ_HOME,\"\\nPlease setup FUNZ_HOME to your Funz installation path.\\n(you can get Funz freely at http://funz.irsn.fr)\",sep=\"\"))\n    \n    wd = getwd()\n    setwd(FUNZ_HOME)\n   \n    parameters = c(parameters,paste(\"-Dapp.home\",FUNZ_HOME,sep=\"=\"))  \n    if (!is.null(headless)) {\n        if (isTRUE(headless)) headless=\"true\" else headless=\"false\"\n        parameters = c(parameters,paste(\"-Djava.awt.headless\",headless,sep=\"=\"))\n    }\n    if (!is.null(verbose.level))\n        parameters = c(parameters,paste(\"-Dverbose.level\",verbose.level,sep=\"=\"))\n    \n    .jinit(parameters=parameters, ...) \n    \n    cat(paste(\"Java \",.jcall(.System,\"S\",\"getProperty\",\"java.runtime.name\"),\"\\n version \",.jcall(.System,\"S\",\"getProperty\",\"java.version\"),\"\\n from path \",.jcall(.System,\"S\",\"getProperty\",\"java.home\"),\"\\n\",sep=\"\"))\n\n    for (f in list.files(path=paste(FUNZ_HOME,\"lib\",sep=\"/\"),pattern=\".jar\")) {\n        #print(paste(FUNZ_HOME,\"lib\",f,sep=\"/\"))\n        .jaddClassPath(path=paste(FUNZ_HOME,\"lib\",f,sep=\"/\"))\n    }\n    \n    cat(paste(\"Funz \",.jfield(.Constants,,\"APP_VERSION\"),\" <build \",.jfield(.Constants,,\"APP_BUILD_DATE\"),\">\\n\",sep=\"\"))\n\n    .Funz.models <<- .jfield(.RunShell,, \"MODELS\")\n    .Funz.designs <<- .jfield(.DesignShell,, \"DESIGNS\")\n\n    .jcall(.Shell,.JNI.Void,\"setConsoleVisible\",as.logical(console.visible))\n    .jcall(.Shell,.JNI.Void,\"setMathConsoleVisible\",as.logical(math.console.visible))\n\n    setwd(wd)\n}\n\n#' Apply a design of experiments through Funz environment on a response surface.\n#' example of optimization using CG:\n#'   Funz.design(design = \"Conjugate Gradient\", options = list(Maximum_iterations=10),\n#'                    input.variables = list(a=\"[-2,1]\",b=\"[-1,2]\"), fun = function(X){abs(X[,1]*X[,2])})\n#' @param design Design of Expetiments (DoE) given by its name (for instance \"\"). See .Funz.designs global var for a list of possible values.\n#' @param input.variables list of variables definition in a String (for instance x1=\"[-1,1]\")\n#' @param options list of options to pass to the DoE. All options not given are set to their default values. Note that '_' char in names will be replaced by ' '.\n#' @param fun response surface as a target (say objective when optimization) function of the DoE. This should include calls to Funz.run() function.\n#' @param fun.cache set to TRUE if you wish to search in previous evaluations of fun befaore launching a new experiment. Sometimes useful when design asks for same experiments many times. Always FALSE if fun is not repeatible.\n#' @param vectorize Set to \"fun\" (by default) if fun accepts nrows>1 data.frame input. Set to \"foreach\" if delegating to 'foreach' loop the parallelization of separate 'fun' calls (packages foreach required, and a DoPar needs to be registered and started before, and shutdown after). Set to \"multicore\" if delegating to 'multicore' the parallelization of separate 'fun' calls. Set to FALSE or \"apply\" means apply() will be used for serial launch of experiments.\n#' @param vectorize.cores set the number of parallel execution if vectorize is set to \"foreach\" or \"multicore\". By default, set to the number of core of your computer (if known by R, otherwise set to 4).\n#' @param foreach.options optional parameters to pass to the foreach DoPar. Should include anything needed for 'fun' evaluation.\n#' @param archive.dir define an arbitrary output directory where results (log, images) are stored.\n#' @param verbose.level print (lot of) information while running.\n#' @param notify.mailto destination of a mail sent (using sendmailR package, required) when design is finished. Sendmail options may be previously defined using sendmailOptions() fomr sendmailR package.\n#' @return list of results from this DoE.\nFunz.design <- function(design=NULL,input.variables=NULL,options=NULL,analyse.tmp=TRUE,fun=NULL,fun.cache=FALSE,vectorize=\"fun\",vectorize.cores=getOption(\"cores\"),foreach.options=NULL,archive.dir=NULL,verbose.level=0,log.file=TRUE,notify.mailto=NULL,...) {\n    if (is.null(design))\n        stop(paste(\"Design 'design' must be specified.\"))\n    \n    if (exists(\".Funz.designs\"))\n        if (!is.element(el=design,set=.Funz.designs)) \n            stop(paste(\"Design\",design,\"is not available in this Funz workbench.\"))\n    \n    if (is.null(input.variables))\n        stop(paste(\"Input variables 'input.variables' must be specified.\"))\n    \n    if (is.null(fun))\n        stop(paste(\"Function 'fun' must be specified.\"))\n    \n    if (!is.null(vectorize)) {\n        if (vectorize==\"foreach\") {\n            if (!require(foreach)) \n                stop(\"foreach package is required.\")\n            if (!getDoParRegistered()) \n                stop(\"no foreach backend registered.\")\n        } else if (vectorize==\"multicore\") {\n            if (!require(multicore)) \n                stop(\"multicore package is required.\")\n        }\n        if (is.null(vectorize.cores)) vectorize.cores=4\n    }\n\n    # Internal functions\n    RVectorToStringArray <- function(y) {\n        if (length(y)==0) \n            return(.jcast(.jarray(.jnew(class=.String,\"\")),new.class=.JNI.String.array, convert.array =TRUE))\n        \n        values.jlist = c()\n        for (i in y) {\n            values.j.i = .jnew(class=.String,paste(i))\n            values.jlist = c(values.jlist,values.j.i)\n        }\n        values = .jcast(.jarray(values.jlist),new.class=.JNI.String.array, convert.array =TRUE)\n        return(values)\n        # .jevalArray(values)\n    }\n    \n    RVectorFromStringArray <- function(string.array) {\n        l = c()\n        if (length(string.array)>0)\n            for (i in 1:length(string.array)) {\n                if (is.character(string.array[[i]])) \n                    l = c(l,as.numeric(string.array[[i]])) \n                else\n                    l = c(l,as.numeric(string.array[[i]]$toString()))\n            }\n        return(l)    \n    }\n    \n    FromStringArray <- function(string.array) {\n        l = c()\n        if (length(string.array)>0)\n            for (i in 1:string.array$length) {\n                if (is.character(string.array[[i]])) \n                    l = c(l,string.array[[i]]) \n                else\n                    l = c(l,string.array[[i]]$toString())\n            }\n        return(l)    \n    }\n    \n    MapToDataFrame <- function(x){\n        l = list()\n        vars = .jcall(.Shell,.JNI.String.array,\"keys\",x)\n        for (v in vars) {\n            val = .jcast(.jcall(x,.JNI.Object,\"get\",.jcast(.jnew(.String,v),new.class=.Object)),new.class=.JNI.String.array)\n            vals = RVectorFromStringArray(.jevalArray(val))\n            l[[v]] = vals\n        }    \n        return(as.data.frame(l))\n    }\n    \n    MapToList <- function(x){\n        l = list()\n        vars = .jcall(.Shell,.JNI.String.array,\"keys\",x)\n        for (v in vars) {\n            val = .jcast(.jcall(x,.JNI.Object,\"get\",.jcast(.jnew(.String,v),new.class=.Object)),new.class=.JNI.String.array)\n            if (is.character(val)) \n                l[[v]] = val\n            else \n                l[[v]] = val$toString()\n        }    \n        return(l)\n    }\n    \n    # Build input as a HashMap<String, String>\n    input.variables.jmap<-.jnew(.LinkedHashMap)\n    for (key in names(input.variables)) {\n        if (is.null(input.variables[[key]]))\n            values = \"[0,1]\"\n        else \n            values = input.variables[[key]]\n        values = .jcast(.jnew(class=.String,values),new.class=.Object)\n        .jcall(input.variables.jmap,.JNI.Object,\"put\",.jcast(.jnew(class=.String,key),.Object), values)\n    }\n    \n    # Set design options\n    if(!is.null(options)) {\n        options.jmap<-.jnew(.HashMap)\n        for (key in names(options)) {\n            values = .jcast(.jnew(class=.String,paste(options[[key]])),new.class=.Object)\n            .jcall(options.jmap,.JNI.Object,\"put\",.jcast(.jnew(class=.String,gsub(\"_\",\" \",key)),.Object), values)\n        }\n        \n    } else if (verbose.level>0) {\n        cat(\"Using default options\\n\")\n    }\n    \n    # Initiate static parameters\n    .jcall(.Shell,.JNI.Void,\"setVerboseLevel\",as.integer(verbose.level))\n    \n    # Let's instanciate the workbench\n    shell = .jnew(class=.DesignShell,design,.jcast(input.variables.jmap,new.class=.Map))\n    .jcall(shell,.JNI.Void,\"trap\",\"INT\") # to not allow ctrl-c to stop whole JVM, just this shell\n    \n    # If no output dir is provided, use current one\n    if(is.null(archive.dir)) archive.dir = getwd()\n    if (!.is.absolute(archive.dir)) archive.dir = file.path(getwd(),archive.dir)\n    .jcall(shell,.JNI.Void,\"setArchiveDirectory\",.jnew(class=.String,archive.dir))\n    if (verbose.level>0) {\n        cat(\"Using archive directory: \")\n        cat(archive.dir)\n        cat(\"\\n\")\n    }\n    \n    if (isTRUE(log.file)) {\n        # Then redirect output/error streams in the archive dir\n        .jcall(shell,.JNI.Void,\"redirectOutErr\") # to keep log of in/err streams\n    }\n\n    if(exists(\"options.jmap\")) {\n        .jcall(shell,.JNI.Void,\"setOptions\",options.jmap)\n    }\n    \n    if (verbose.level>0) {\n        cat(.jcall(shell,.JNI.String,\"information\"))\n        cat(\"\\n\")\n    }\n    \n    .jcall(shell,.JNI.Void,\"setCacheExperiments\",as.logical(fun.cache))\n    \n    jX = .jcall(shell,.JNI.Map,\"initDesign\")\n    if (verbose.level>0) {\n        cat(\"Initial design\\n\")\n        cat(.jcall(shell,.JNI.String,\"nextExperimentsInformation\"));\n        cat(\"\\n\")\n    }\n    \n    it = 1;\n    while (TRUE) {\n        X = MapToDataFrame(jX)\n        n = nrow(X)\n        if(n>0) {\n            if (is.null(vectorize) || vectorize==FALSE || vectorize==\"apply\") {\n                Y = apply(X=X,FUN=fun,MARGIN=1,...)\n            } else if (vectorize==\"fun\") {\n                Y = fun(X,...)\n            } else if (vectorize==\"foreach\") {\n                if (!is.null(foreach.options)) {\n                    if (getDoParName()==\"doMC\")\n                        Y = foreach(ix = 1:nrow(X), .combine = c, .options.multicore = c(cores=vectorize.cores,foreach.options)) %dopar% fun(X[ix,],...)\n                    else if (getDoParName()==\"doSMP\")\n                        Y = foreach(ix = 1:nrow(X), .combine = c, .options.smp = c(chunkSize=vectorize.cores,foreach.options)) %dopar% fun(X[ix,],...)\n                    else\n                        Y = foreach(ix = 1:nrow(X), .combine = c, .options = foreach.options) %dopar% fun(X[ix,],...)\n                } else {\n                    Y = foreach(ix = 1:nrow(X), .combine = c) %dopar% fun(X[ix,],...)\n                }\n            } else if (vectorize==\"multicore\") {\n                Y = (mclapply(X=split(X, 1:nrow(X)),FUN=fun,mc.cores=vectorize.cores,...))\n            } else {\n                stop(paste(\"vectorize type '\",vectorize,\"' not supported.\",sep=\"\"))\n            }\n        } else Y = c()\n        \n        if (is.null(Y) || length(Y) != n) stop(paste(\"Failed to evaluate 'fun' on experiment sample X:\",paste(Y)))\n        \n        jX = NULL\n        jX = .jcall(shell,.JNI.Map,\"nextDesign\",RVectorToStringArray(Y))\n        \n        if (is.jnull(jX)) break;\n        \n        if (isTRUE(analyse.tmp)) {\n            janalysetmp = .jcall(shell,.JNI.Map,\"analyseDesignTmp\")\n            if (is.jnull(janalysetmp )) {\n                analysetmp = MapToList(janalysetmp )\n                if (verbose.level>0) \n                for (i in names(analysetmp)) {\n                    cat(i,\"\\n  \",paste(analysetmp[[i]],\"\\n\"))\n                }\n            }\n        }\n\n        #cat(.jcall(shell,JNI.String,\"finishedExperimentsInformation\"));\n        if (verbose.level>0) {\n            cat(paste(it,\"th iteration\\n\",sep=\"\"))\n            cat(.jcall(shell,.JNI.String,\"nextExperimentsInformation\"));\n            cat(\"\\n\")\n        }\n        it = it+1;\n    }\n    \n    analyse = .jcall(shell,.JNI.Map,\"analyseDesign\")\n    \n    results = MapToList(analyse)\n\n    experiments = .jcall(shell,.JNI.Map,\"finishedExperimentsMap\")\n\n    results$design = MapToDataFrame(experiments)\n\n    .jdelete(shell)\n\n    if(!is.null(notify.mailto)) {\n         if (!require(sendmailR)) \n              warning(\"sendmailR package not available. No notification mail sent.\")\n         else \n              sendmail(to=notify.mailto,from=sprintf(\"Funz@%s\", Sys.info()[4]),subject=paste(\"[Funz.design]\",design),msg=paste(names(results),\"=\",results,collapse=\",\"))\n    }\n\n    return(results)\n}\n\n#' Conveniency method giving information about a design available as Funz.design() arg.\n#' @return information about this design.\nFunz.design.info <- function(design=NULL, input.variables=list(x1=NULL,x2=NULL)) {\n    if (is.null(design))\n        stop(paste(\"Design 'design' must be specified.\"))\n    \n    if (exists(\".Funz.designs\"))\n        if (!is.element(el=design,set=.Funz.designs)) \n            stop(paste(\"Design\",design,\"is not available in this Funz workbench.\"))\n    \n    # Build input as a HashMap<String, String>\n    input.variables.jmap<-.jnew(.LinkedHashMap)\n    for (key in names(input.variables)) {\n        if (is.null(input.variables[[key]]))\n            values = \"[0,1]\"\n        else \n            values = input.variables[[key]]\n        values = .jcast(.jnew(class=.String,values),new.class=.Object)\n        .jcall(input.variables.jmap,.JNI.Object,\"put\",.jcast(.jnew(class=.String,key),.Object), values)\n    }\n    \n    # Let's instanciate the workbench \n    shell = .jnew(class=.DesignShell,design,.jcast(input.variables.jmap,new.class=.Map))\n    \n    info = .jcall(shell,.JNI.String,\"information\")\n\n    .jdelete(shell)\n\n    cat(info)\n}\n\n\n#' Call an external (to R) code wrapped through Funz environment.\n#' example of usage when code is R (yes, it is a toy application :)\n#'   Funz.run(model = \"[R]\", input.files = file.path(FUNZ_HOME,\"samples\",\"branin.R\"), \n#'                 input.design = list(a=runif(10), b=runif(10)), output.expressions = \"z\")\n#' @param model name of the code wrapper to use. See .Funz.models global var for a list of possible values.\n#' @param input.files list of files to give as input for the code.\n#' @param input.design data.frame of input variable values. If more than one experiment (i.e. nrow >1), experiments will be launched simultaneously on the Funz grid.\n#' @param output.expressions list of interest output from the code. Will become the names() of return list.\n#' @param archive.dir define an arbitrary output directory where results (cases, csv files) are stored.\n#' @param verbose.level print (lot of) information while running.\n#' @param notify.mailto destination of a mail sent (using sendmailR package, required) when computing is finished. Sendmail options may be previously defined using sendmailOptions() fomr sendmailR package.\n#' @param sleep delay time between two checks of results.\n#' @param display.state a function to display project cases status. Argument passed to is the data.frame of DoE state.\n#' @return list of array results from the code, arrays size being equal to input.design arrays size.\nFunz.run <- function(model=NULL,input.files,input.design=NULL,output.expressions=NULL,archive.dir=NULL,force.retry=2,cache.dir=NULL,verbose.level=0,log.file=TRUE,notify.mailto=NULL,sleep=1,display.state=NULL) {\n    if (exists(\".Funz.models\"))\n        if (!is.null(model) && (!is.element(el=model,set=.Funz.models))) \n            stop(paste(\"Model\",model,\"is not available in this Funz workbench.\"))\n    \n    if (is.null(model)) {\n        model <- \"\"\n        if (verbose.level>0) cat(\"Using default model.\\n\")\n    }\n    \n    asObject <- function(string) {\n        jo <- NULL\n        try(jo <- .jcall(.ASCII,returnSig =.JNI.Object,\"asObject\",string))\n        if (is.jnull(jo)) return(NULL)\n        array <- NULL\n        try(array <- .jevalArray(jo))\n        if (!is.null(array)) return(array)\n        else return(jo)\n    }\n    \n    # Check (and wrap to Java) input files.\n    input.files.jlist = c()\n    for (i in input.files) {\n        if (.is.absolute(i))\n            input.files.i = i\n        else\n            input.files.i = file.path(getwd(),i)\n        input.files.j.i = .jnew(class=.File,input.files.i)\n        found = .jcall( input.files.j.i,.JNI.boolean,\"isFile\")\n        if (!found) \n            stop(paste(\"Input file \",input.files.i,\" not found.\",sep=\"\"))\n        input.files.jlist = c(input.files.jlist,input.files.j.i)\n    }\n    input.files.jarray = .jcast(.jarray(input.files.jlist),.JNI.File.array, convert.array =TRUE)\n    \n    # First, process the input design, because if it includes a call to Funz itself (compisition of Funz functions), it will lock Funz as long as nothing is returned.\n    if(!is.null(input.design)) {\n        input.design.jmap<-.jnew(.LinkedHashMap)\n        for (key in names(input.design)) {\n            values.jlist = c()\n            for (i in input.design[[key]]) {\n                values.j.i = .jnew(class=.String,paste(i))\n                values.jlist = c(values.jlist,values.j.i)\n            }\n            values = .jcast(.jarray(values.jlist),new.class=.Object)\n            .jcall(input.design.jmap,.JNI.Object,\"put\",.jcast(.jnew(class=.String,key),.Object), values)\n        }\n    } else if (verbose.level>0) cat(\"Using default input design.\\n\")\n    \n    # Initiate static parameters\n    .jcall(.Shell,.JNI.Void,\"setVerboseLevel\",as.integer(verbose.level))\n    \n    # Let's instanciate the workbench\n    if (exists(\"runshell\")) if(!is.null(runshell)) {cat(\"Terminating previous run...\");.jcall(runshell,.JNI.Void,\"shutdown\");cat(\" ok.\\n\");}\n    runshell <<- .jnew(class=.RunShell,model,input.files.jarray)\n    .jcall(runshell,.JNI.Void,\"trap\",\"INT\") # to not allow ctrl-c to stop whole JVM, just this runshell\n    \n    # If no output dir is provided, use current one\n    if(is.null(archive.dir)) archive.dir = getwd()\n    if (!.is.absolute(archive.dir)) archive.dir = file.path(getwd(),archive.dir)\n    .jcall(runshell,.JNI.Void,\"setArchiveDirectory\",.jnew(class=.String,archive.dir))\n    if (verbose.level>0) {\n        cat(\"Using archive directory: \")\n        cat(archive.dir)\n        cat(\"\\n\")\n    }\n        \n    if (isTRUE(log.file)) {\n        # Then redirect output/error streams in the archive dir\n        .jcall(runshell,.JNI.Void,\"redirectOutErr\") # to keep log of in/err streams\n    }\n    \n    # Set number of retries\n    .jcall(runshell,.JNI.Void,\"setRetries\",as.integer(force.retry))\n    \n    # Manage the output : if nothing is provided, use default one from plugin\n    if(is.null(output.expressions)) {\n        output.expressions = .jcall(runshell,.JNI.String.array,\"getOutputAvailable\")\n        if (verbose.level>0) {\n            cat(\"Using default output expressions:\")\n            cat(output.expressions)\n            cat(\"\\n\")\n        }\n    }\n    output.expressions.jlist = c()\n    for (i in output.expressions) {\n        output.j.i = .jnew(class=.String,i)\n        output.expressions.jlist = c(output.expressions.jlist,output.j.i)\n    }\n    output.expressions.jarray = .jcast(.jarray(output.expressions.jlist),.JNI.String.array, convert.array =TRUE)\n    .jcall(runshell,.JNI.Void,\"setOutputExpressions\",output.expressions.jarray)\n    \n    # Now, if input design was provided, use it. Instead, default parameters values will be used.\n    if(exists(\"input.design.jmap\")) {\n        .jcall(runshell,.JNI.Void,\"setInputExperiments\",.jcast(input.design.jmap,new.class=.Map))\n    }\n    \n    # Finally, adding cache if needed\n    if(!is.null(cache.dir)) {\n        for (dir in cache.dir) {\n            .jcall(runshell,.JNI.Void,\"addCacheDirectory\",.jnew(class=.File,dir))\n        }\n    }\n    \n    # Everything is ok. let's run calculations now !\n    runshell.thread = .jnew(class=\"java/lang/Thread\",.jcast(runshell,\"java/lang/Runnable\"))\n    .jcall(runshell.thread,returnSig = .JNI.Void,\"start\")\n\n    finished = FALSE\n    while(!finished) {\n        tryCatch(expr={.done <<- FALSE; \n                       Sys.sleep(sleep);\n                       state = .jcall(runshell,.JNI.String,\"getState\");\n                       finished = (state == \"Done.\");\n                       if (verbose.level>2) cat(paste(\"\\n\",state));\n                       if (is.function(display.state)) display.state(read.delim(textConnection(.jcall(runshell,.JNI.String,\"getCSVState\")),sep=\";\"));\n                       .done <<- TRUE;\n                      },\n            finally={if(!.done) {cat(\"Terminating run...\");.jcall(runshell,.JNI.Void,\"shutdown\");cat(\" ok.\\n\");}})\n    }\n    #cat(.jcall(runshell,.JNI.String,\"getResultsString\"))\n    results =.jcall(runshell,.JNI.Map,\"getResultsMap\")\n\n    .jdelete(runshell)\n    \n    #ret_obj = .jcall(.jcall(results,returnSig =\"Ljava/util/Set;\",method=\"keySet\"),returnSig = \"[Ljava/lang/Object;\",method=\"toArray\")\n    #ret_names = list()\n    #for (i in (ret_obj)) {\n    #  ret_names = c(ret_names,.jcast(i,new.class = \"Ljava/lang/String;\"))\n    #}\n    #print(ret_names)\n    \n    info.error = .jcast(.jcall(results,returnSig = .JNI.Object,method=\"get\",.jcast(.jnew(.String,\"info.error\"),.Object)),new.class = .JNI.String.array,convert.array =TRUE)\n    errors = .jcall(.ASCII,.JNI.String,\"cat\",.jnew(class=.String,\"\"),info.error)\n    if (length(errors)>0 && nchar(errors)>0) {\n        if (verbose.level>0) cat(.jcall(.ASCII,.JNI.String,\"cat\",results))\n        stop(paste(\"Error: \",paste(errors,sep=\"\\n        \"),sep=\"\"))\n    } #else print(\"No error\")\n    \n    output.array = list();\n    for (i in output.expressions) {\n        #print(i)\n        o.j = .jcall(results,returnSig = .JNI.Object,method=\"get\",.jcast(.jnew(.String,i),.Object))\n        output.array[[i]] = NULL\n        output.array.j = NULL\n        if (!is.jnull(o.j)) {\n            output.array.j <- .jevalArray(.jcast(o.j,new.class = .JNI.String.array))\n            if (!is.na(output.array.j) && !is.null(output.array.j))\n                try(output.array[[i]] <- as.numeric(output.array.j),silent=(verbose.level<=0))\n        }\n        if (!is.null(output.array.j) && !is.null(output.array[[i]]) && is.na(output.array[[i]])){\n            data <- NULL            \n            try(data <- t(as.data.frame(lapply(FUN=asObject,output.array.j))))\n            if(!is.null(data)) row.names(data) <- NULL\n            output.array[[i]] <- data\n        }\n    }\n\n    if(!is.null(notify.mailto)) {\n         if (!require(sendmailR)) \n              warning(\"sendmailR package not available. No notification mail sent.\")\n         else \n         \tsendmail(to=notify.mailto,from=sprintf(\"Funz@%s\", Sys.info()[4]),subject=paste(\"[Funz.run]\",model),msg=paste(names(output.array),\"=\",output.array,collapse=\",\"))\n         \n    }\n\n    return(output.array)\n}\n\n#' Conveniency test & information of Funz.run model & input.\n#' @return general information concerning this model/input combination.\nFunz.run.info <- function(model=NULL,input.files=NULL) {\n    if (exists(\".Funz.models\"))\n        if (!is.null(model) && (!is.element(el=model,set=.Funz.models))) \n            stop(paste(\"Model\",model,\"is not available in this Funz workbench.\"))\n    \n    if (is.null(model)) {\n        model <- \"\"\n        if (verbose.level>0) cat(\"Using default model.\\n\")\n    }\n    \n    # Check (and wrap to Java) input files.\n    input.files.jlist = c()\n    for (i in input.files) {\n        if (.is.absolute(i))\n            input.files.i = i\n        else\n            input.files.i = file.path(getwd(),i)\n        input.files.j.i = .jnew(class=.File,input.files.i)\n        found = .jcall( input.files.j.i,.JNI.boolean,\"isFile\")\n        if (!found) \n            stop(paste(\"Input file \",input.files.i,\" not found.\",sep=\"\"))\n        input.files.jlist = c(input.files.jlist,input.files.j.i)\n    }\n    input.files.jarray = .jcast(.jarray(input.files.jlist),.JNI.File.array, convert.array =TRUE)\n    \n    # Let's instanciate the workbench\n    shell = .jnew(class=.RunShell,model,input.files.jarray)\n    \n    # Get default variables from plugin\n    info = .jcall(shell,.JNI.String,\"projectInformation\")\n    \n    .jdelete(shell)\n\n    cat(info);\n}\n\n#' Conveniency overview of Funz grid status.\n#' @return String list of all visible Funz daemons running on the network.\nFunz.grid.info <- function() {\n    read.delim(textConnection(gsub(\"\\t\",\"\",.jcall(.RunShell,.JNI.String,\"gridStatusInformation\"))),sep=\"|\")[,2:7]\n}",
    "created" : 1350487009309.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2943817623",
    "id" : "CA40C8B9",
    "lastKnownWriteTime" : 1349876736,
    "path" : "~/Documents/work/funz/code/trunk/applications/funz-client/src/main/resources/scripts/funz.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}